<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>I2C.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_fd93339bedb917e61f14a383cae95c74.html">tidrivers_cc13xx_cc26xx_3_20_01_00</a></li><li class="navelem"><a class="el" href="dir_3b1c21f291b9b5fd65602f608052e36b.html">source</a></li><li class="navelem"><a class="el" href="dir_ea9185700b4a00039b45040cbcc0570b.html">ti</a></li><li class="navelem"><a class="el" href="dir_4df65e1d267425c614acc66379e8abfd.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>I2C driver interface. </p>
<hr/>
<p>The I2C driver interface provides device independent APIs, data types, and macros. The I2C header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i2_c_8h.html">ti/drivers/I2C.h</a>&gt;</span></div></div><!-- fragment --><h1>Overview</h1>
<p>This section assumes that you have background knowledge and understanding about how the I2C protocol operates. For the full I2C specifications and user manual (UM10204), see the NXP Semiconductors website.</p>
<p>The I2C driver has been designed to operate as a single I2C master by performing I2C transactions between the target and I2C slave peripherals. The I2C driver does not support I2C slave mode. I2C is a communication protocol - the specifications define how data transactions are to occur via the I2C bus. The specifications do not define how data is to be formatted or handled, allowing for flexible implementations across different peripheral vendors. As a result, the I2C handles only the exchange of data (or transactions) between master and slaves. It is the left to the application to interpret and manipulate the contents of each specific I2C peripheral.</p>
<p>The I2C driver has been designed to operate in an RTOS environment. It protects its transactions with OS primitives supplied by the underlying RTOS.</p>
<h1>Usage</h1>
<p>The I2C driver includes the following APIs:</p><ul>
<li><a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a>: Initialize the I2C driver.</li>
<li><a class="el" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c" title="Initialize an I2C_Params struct to its defaults. ">I2C_Params_init()</a>: Initialize an <a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749" title="I2C Parameters. ">I2C_Params</a> structure with default vaules.</li>
<li><a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>: Open an instance of the I2C driver.</li>
<li><a class="el" href="_i2_c_8h.html#a4c74b1b9f8e76ac22bec7608491cb223" title="Perform implementation-specific features on a given I2C_Handle. ">I2C_control()</a>: Performs implemenation-specific features on a given I2C peripheral.</li>
<li><a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a>: Transfer the data.</li>
<li><a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d" title="Close an I2C peripheral specified by an I2C_Handle. ">I2C_close()</a>: De-initialize the I2C instance.</li>
</ul>
<h3>I2C Driver Configuration</h3>
<p>In order to use the I2C APIs, the application is required to provide device-specific I2C configuration in the Board.c file. The I2C driver interface defines a configuration data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_i2_c___config__.html">I2C_Config_</a> {</div><div class="line">    <a class="code" href="struct_i2_c___fxn_table__.html">I2C_FxnTable</a>  <span class="keyword">const</span>    *<a class="code" href="struct_i2_c___config__.html#a635dcef77b14e153ffb35e270cd46886">fxnTablePtr</a>;</div><div class="line">    <span class="keywordtype">void</span>                   *<a class="code" href="struct_i2_c___config__.html#a8bdac95426bbb6b46559fab1e81898ba">object</a>;</div><div class="line">    <span class="keywordtype">void</span>          <span class="keyword">const</span>    *<a class="code" href="struct_i2_c___config__.html#af4722d351fb7137a34166e047a4f96bc">hwAttrs</a>;</div><div class="line">} <a class="code" href="_i2_c_8h.html#ae43e4c7b224a8cc37764acb792182453">I2C_Config</a>;</div></div><!-- fragment --><p>The application must declare an array of I2C_Config elements, named I2C_config[]. Each element of I2C_config[] must be populated with pointers to a device specific I2C driver implementation's function table, driver object, and hardware attributes. The hardware attributes define properties such as the I2C peripheral's base address and pins. Each element in I2C_config[] corresponds to an I2C instance, and none of the elements should have NULL pointers. There is no correlation between the index and the peripheral designation (such as I2C0 or I2C1). For example, it is possible to use I2C_config[0] for I2C1.</p>
<p>Because the I2C configuration is very device dependent, you will need to check the doxygen for the device specific I2C implementation. There you will find a description of the I2C hardware attributes. Please also refer to the Board.c file of any of your examples to see the I2C configuration.</p>
<h3>Initializing the I2C Driver</h3>
<p><a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a> must be called before any other I2C APIs. This function iterates through the elements of the I2C_config[] array, calling the element's device implementation I2C initialization function.</p>
<h3>I2C Parameters</h3>
<p>The <a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749" title="I2C Parameters. ">I2C_Params</a> structure is passed to the <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> call. If NULL is passed for the parameters, <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> uses default parameters. An <a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749" title="I2C Parameters. ">I2C_Params</a> structure is initialized with default values by passing it to <a class="el" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c" title="Initialize an I2C_Params struct to its defaults. ">I2C_Params_init()</a>. Some of the I2C parameters are described below. To see brief descriptions of all the parameters, see <a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749" title="I2C Parameters. ">I2C_Params</a>.</p>
<h4>I2C Transfer Mode</h4>
<p>The I2C driver supports two transfer modes of operation: blocking and callback:</p><ul>
<li><a class="el" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>: The call to <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> blocks until the transfer completes.</li>
<li><a class="el" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>: The call to <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> returns immediately. When the transfer completes, the I2C driver will call a user- specified callback function.</li>
</ul>
<p>The transfer mode is determined by the <a class="el" href="struct_i2_c___params__.html#a1c126475468cfc6ce397a520aea93936">I2C_Params.transferMode</a> parameter passed to <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>. The I2C driver defaults to blocking mode, if the application does not set it.</p>
<p>In blocking mode, a task calling <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> is blocked until the transaction completes. Other tasks requesting I2C transactions while a transaction is currently taking place, are also placed into a blocked state.</p>
<p>In callback mode, an <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> functions asynchronously, which means that it does not block a calling task's execution. In this mode, the user must set <a class="el" href="struct_i2_c___params__.html#acd2b2ca0da16c1f017ac32cc4831b31e">I2C_Params.transferCallbackFxn</a> to a user- provided callback function. After an I2C transaction has completed, the I2C driver calls the user- provided callback function. If another I2C transaction is requested, the transaction is queued up. As each transfer completes, the I2C driver will call the user-specified callback function. The user callback will be called from either hardware or software interrupt context, depending upon the device implementation.</p>
<p>Once an I2C driver instance is opened, the only way to change the transfer mode is to close and re-open the I2C instance with the new transfer mode.</p>
<h4>Specifying an I2C Bus Frequency</h4>
<p>The I2C controller's bus frequency is determined by <a class="el" href="struct_i2_c___params__.html#a03607c385a4e9dd1f29338ec0309a858">I2C_Params.bitRate</a> passed to <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>. The standard I2C bus frequencies are 100 kHz and 400 kHz, with 100 kHz being the default.</p>
<h3>Opening the I2C Driver</h3>
<p>After initializing the I2C driver by calling <a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a>, the application can open an I2C instance by calling <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>. This function takes an index into the I2C_config[] array and an I2C parameters data structure. The I2C instance is specified by the index of the I2C in I2C_config[]. Only one I2C index can be used at a time; calling <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> a second time with the same index previosly passed to <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> will result in an error. You can, though, re-use the index if the instance is closed via <a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d" title="Close an I2C peripheral specified by an I2C_Handle. ">I2C_close()</a>.</p>
<p>If no I2C_Params structure is passed to <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>, default values are used. If the open call is successful, it returns a non-NULL value.</p>
<p>Example opening an I2C driver instance in blocking mode: </p><div class="fragment"><div class="line"><a class="code" href="struct_i2_c___config__.html">I2C_Handle</a> i2c;</div><div class="line"></div><div class="line"><span class="comment">// NULL params are used, so default to blocking mode, 100 KHz</span></div><div class="line">i2c = <a class="code" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6">I2C_open</a>(Board_I2C0, NULL);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!i2c) {</div><div class="line">    <span class="comment">// Error opening the I2C</span></div><div class="line">}</div></div><!-- fragment --><p>Example opening an I2C driver instance in callback mode and 400KHz bit rate:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_i2_c___config__.html">I2C_Handle</a> i2c;</div><div class="line"><a class="code" href="struct_i2_c___params__.html">I2C_Params</a> params;</div><div class="line"></div><div class="line"><a class="code" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c">I2C_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_i2_c___params__.html#a1c126475468cfc6ce397a520aea93936">transferMode</a>  = <a class="code" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>;</div><div class="line">params.<a class="code" href="struct_i2_c___params__.html#acd2b2ca0da16c1f017ac32cc4831b31e">transferCallbackFxn</a> = myCallbackFunction;</div><div class="line">params.<a class="code" href="struct_i2_c___params__.html#a03607c385a4e9dd1f29338ec0309a858">bitRate</a>  = <a class="code" href="_i2_c_8h.html#adf9ba181c193aea867303fb6e6471db9a83cc3750242e6ae9194cd7ed94f764d9">I2C_400kHz</a>;</div><div class="line"></div><div class="line">handle = <a class="code" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6">I2C_open</a>(Board_I2C0, &amp;params);</div><div class="line"><span class="keywordflow">if</span> (!i2c) {</div><div class="line">    <span class="comment">// Error opening I2C</span></div><div class="line">}</div></div><!-- fragment --><h3>Transferring data</h3>
<p>An I2C transaction with an I2C peripheral is started by calling <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a>. Three types of transactions are supported: Write, Read, or Write/Read. Each transfer is completed before another transfer is initiated.</p>
<p>For Write/Read transactions, the specified data is first written to the peripheral, then a repeated start is sent by the driver, which initiates the read operation. This type of transfer is useful if an I2C peripheral has a pointer register that needs to be adjusted prior to reading from the referenced data register.</p>
<p>The details of each transaction are specified with an <a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51" title="I2C transaction. ">I2C_Transaction</a> data structure. This structure defines the slave I2C address, pointers to write and read buffers, and their associated byte counts. If no data needs to be written or read, the corresponding byte counts should be set to zero.</p>
<p>If an I2C transaction is requested while a transaction is currently taking place, the new transaction is placed onto a queue to be processed in the order in which it was received.</p>
<p>The below example shows sending three bytes of data to a slave peripheral at address 0x50, in blocking mode:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> writeBuffer[3];</div><div class="line"><a class="code" href="struct_i2_c___transaction__.html">I2C_Transaction</a> i2cTransaction;</div><div class="line"></div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a09a6dc5d7ab40ed03cb0442feb456889">slaveAddress</a> = 0x50;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a5d9c494aca871ebb272899856e1fa6bb">writeBuf</a> = writeBuffer;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a3bee82494f85dc33d1229e48a2ec63c8">writeCount</a> = 3;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#aca335a8f98036308396f27fddeb96f7b">readBuf</a> = NULL;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a175470cacf5d42b11d505e2196ff6494">readCount</a> = 0;</div><div class="line"></div><div class="line">status = <a class="code" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction);</div><div class="line"><span class="keywordflow">if</span> (!status) {</div><div class="line">    <span class="comment">// Unsuccessful I2C transfer</span></div><div class="line">}</div></div><!-- fragment --><p>The next example shows reading of five bytes of data from the I2C peripheral, also in blocking mode:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> readBuffer[5];</div><div class="line"><a class="code" href="struct_i2_c___transaction__.html">I2C_Transaction</a> i2cTransaction;</div><div class="line"></div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a09a6dc5d7ab40ed03cb0442feb456889">slaveAddress</a> = 0x50;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a5d9c494aca871ebb272899856e1fa6bb">writeBuf</a> = NULL;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a3bee82494f85dc33d1229e48a2ec63c8">writeCount</a> = 0;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#aca335a8f98036308396f27fddeb96f7b">readBuf</a> = readBuffer;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a175470cacf5d42b11d505e2196ff6494">readCount</a> = 5;</div><div class="line"></div><div class="line">status = <a class="code" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction);</div><div class="line"><span class="keywordflow">if</span> (!status) {</div><div class="line">    <span class="comment">// Unsuccessful I2C transfer</span></div><div class="line">}</div></div><!-- fragment --><p>This example shows writing of two bytes and reading of four bytes in a single transaction.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> readBuffer[4];</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> writeBuffer[2];</div><div class="line"><a class="code" href="struct_i2_c___transaction__.html">I2C_Transaction</a> i2cTransaction;</div><div class="line"></div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a09a6dc5d7ab40ed03cb0442feb456889">slaveAddress</a> = 0x50;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a5d9c494aca871ebb272899856e1fa6bb">writeBuf</a> = writeBuffer;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a3bee82494f85dc33d1229e48a2ec63c8">writeCount</a> = 2;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#aca335a8f98036308396f27fddeb96f7b">readBuf</a> = readBuffer;</div><div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction__.html#a175470cacf5d42b11d505e2196ff6494">readCount</a> = 4;</div><div class="line"></div><div class="line">status = <a class="code" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction);</div><div class="line"><span class="keywordflow">if</span> (!status) {</div><div class="line">    <span class="comment">// Unsuccessful I2C transfer</span></div><div class="line">}</div></div><!-- fragment --><p>This final example shows usage of asynchronous callback mode, with queuing of multiple transactions. Because multiple transactions are simultaneously queued, separate I2C_Transaction structures must be used. (This is a general rule, that I2C_Transaction structures cannot be reused until it is known that the previous transaction has completed.)</p>
<p>First, for the callback function (that is specified in the <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> call) the "arg" in the I2C_Transaction structure is a semaphore handle. When this value is non-NULL, sem_post() is called in the callback using the specified handle, to signal completion to the task that queued the transactions:</p>
<div class="fragment"><div class="line">Void callbackFxn(<a class="code" href="struct_i2_c___config__.html">I2C_Handle</a> handle, <a class="code" href="struct_i2_c___transaction__.html">I2C_Transaction</a> *msg, Bool transfer) {</div><div class="line">    <span class="keywordflow">if</span> (msg-&gt;<a class="code" href="struct_i2_c___transaction__.html#a5c74a2359742d69b0e9108bb342ded00">arg</a> != NULL) {</div><div class="line">        sem_post((sem_t *)(msg-&gt;<a class="code" href="struct_i2_c___transaction__.html#a5c74a2359742d69b0e9108bb342ded00">arg</a>));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Snippets of the task code that initiates the transactions are shown below. Note the use of multiple I2C_Transaction structures, and passing of the handle of the semaphore to be posted via i2cTransaction2.arg. <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> is called three times to initiate each transaction. Since callback mode is used, these functions return immediately. After the transactions have been queued, other work can be done, and then eventually sem_wait() is called to wait for the last I2C transaction to complete. Once the callback posts the semaphore the task will be moved to the ready state, so the task can resume execution.</p>
<div class="fragment"><div class="line">Void taskfxn(arg0, arg1) {</div><div class="line"></div><div class="line">    <a class="code" href="struct_i2_c___transaction__.html">I2C_Transaction</a> i2cTransaction0;</div><div class="line">    <a class="code" href="struct_i2_c___transaction__.html">I2C_Transaction</a> i2cTransaction1;</div><div class="line">    <a class="code" href="struct_i2_c___transaction__.html">I2C_Transaction</a> i2cTransaction2;</div><div class="line"></div><div class="line">    ...</div><div class="line">    i2cTransaction0.<a class="code" href="struct_i2_c___transaction__.html#a5c74a2359742d69b0e9108bb342ded00">arg</a> = NULL;</div><div class="line">    i2cTransaction1.<a class="code" href="struct_i2_c___transaction__.html#a5c74a2359742d69b0e9108bb342ded00">arg</a> = NULL;</div><div class="line">    i2cTransaction2.<a class="code" href="struct_i2_c___transaction__.html#a5c74a2359742d69b0e9108bb342ded00">arg</a> = semaphoreHandle;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <a class="code" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction0);</div><div class="line">    <a class="code" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction1);</div><div class="line">    <a class="code" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(i2c, &amp;i2cTransaction2);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    sem_wait(semaphoreHandle);</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><h1>Implementation</h1>
<p>This top-level I2C module serves as the main interface for RTOS applications. Its purpose is to redirect the module's APIs to specific peripheral implementations which are specified using a pointer to an <a class="el" href="_i2_c_8h.html#a58fd875c3596b3856b6f1aebbceb3085" title="The definition of an I2C function table that contains the required set of functions to control a spec...">I2C_FxnTable</a>.</p>
<p>The I2C driver interface module is joined (at link time) to an array of I2C_Config data structures named <em>I2C_config</em>. <em>I2C_config</em> is typically defined in the Board.c file used for the application. If there are multiple instances of I2C peripherals on the device, there will typically be multiple I2C_Config structures defined in the board file. Each entry in <em>I2C_config</em> contains a:</p><ul>
<li>(I2C_FxnTable *) to a set of functions that implement a I2C peripheral</li>
<li>(void *) data object that is associated with the I2C_FxnTable</li>
<li>(void *) hardware attributes that are associated to the I2C_FxnTable </li>
</ul>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="_i2_c_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___transaction__.html">I2C_Transaction_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transaction.  <a href="struct_i2_c___transaction__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___params__.html">I2C_Params_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Parameters.  <a href="struct_i2_c___params__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___fxn_table__.html">I2C_FxnTable_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of an I2C function table that contains the required set of functions to control a specific I2C driver implementation.  <a href="struct_i2_c___fxn_table__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___config__.html">I2C_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C global configuration.  <a href="struct_i2_c___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga760ec0a6fdb876ccc67b6f06301d53ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___c_o_n_t_r_o_l.html#ga760ec0a6fdb876ccc67b6f06301d53ec">I2C_CMD_RESERVED</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="separator:ga760ec0a6fdb876ccc67b6f06301d53ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd04572fe349d087c2547501cbc7e0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___c_o_n_t_r_o_l.html#gacfd04572fe349d087c2547501cbc7e0a">I2C_STATUS_RESERVED</a>&#160;&#160;&#160;(-32)</td></tr>
<tr class="separator:gacfd04572fe349d087c2547501cbc7e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gaa0bcf3acd26ac82bd8ff91daba2c78c4">I2C_STATUS_SUCCESS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code returned by <a class="el" href="_i2_c_8h.html#a4c74b1b9f8e76ac22bec7608491cb223" title="Perform implementation-specific features on a given I2C_Handle. ">I2C_control()</a>.  <a href="group___i2_c___s_t_a_t_u_s.html#gaa0bcf3acd26ac82bd8ff91daba2c78c4">More...</a><br /></td></tr>
<tr class="separator:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga7323fe57c39c46d0da9910e17f5f0b06">I2C_STATUS_ERROR</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code returned by <a class="el" href="_i2_c_8h.html#a4c74b1b9f8e76ac22bec7608491cb223" title="Perform implementation-specific features on a given I2C_Handle. ">I2C_control()</a>.  <a href="group___i2_c___s_t_a_t_u_s.html#ga7323fe57c39c46d0da9910e17f5f0b06">More...</a><br /></td></tr>
<tr class="separator:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c31c9869ed2441789205d9e5967d66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga11c31c9869ed2441789205d9e5967d66">I2C_STATUS_UNDEFINEDCMD</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:ga11c31c9869ed2441789205d9e5967d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned by <a class="el" href="_i2_c_8h.html#a4c74b1b9f8e76ac22bec7608491cb223" title="Perform implementation-specific features on a given I2C_Handle. ">I2C_control()</a> for undefined command codes.  <a href="group___i2_c___s_t_a_t_u_s.html#ga11c31c9869ed2441789205d9e5967d66">More...</a><br /></td></tr>
<tr class="separator:ga11c31c9869ed2441789205d9e5967d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1d8718f847129c7aa61dd1c264d8a13c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___config__.html">I2C_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a></td></tr>
<tr class="memdesc:a1d8718f847129c7aa61dd1c264d8a13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from an <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> call.  <a href="#a1d8718f847129c7aa61dd1c264d8a13c">More...</a><br /></td></tr>
<tr class="separator:a1d8718f847129c7aa61dd1c264d8a13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9098b8bae10ab04381350227058a51"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___transaction__.html">I2C_Transaction_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51">I2C_Transaction</a></td></tr>
<tr class="memdesc:adb9098b8bae10ab04381350227058a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transaction.  <a href="#adb9098b8bae10ab04381350227058a51">More...</a><br /></td></tr>
<tr class="separator:adb9098b8bae10ab04381350227058a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafde66e55b9cc9b1b0b7a2b924db4e83"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfe">I2C_TransferMode_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#aafde66e55b9cc9b1b0b7a2b924db4e83">I2C_TransferMode</a></td></tr>
<tr class="memdesc:aafde66e55b9cc9b1b0b7a2b924db4e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer mode.  <a href="#aafde66e55b9cc9b1b0b7a2b924db4e83">More...</a><br /></td></tr>
<tr class="separator:aafde66e55b9cc9b1b0b7a2b924db4e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa5c99b7c23a00bac52d15a2469764e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#adaa5c99b7c23a00bac52d15a2469764e">I2C_CallbackFxn</a>) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51">I2C_Transaction</a> *transaction, bool transferStatus)</td></tr>
<tr class="memdesc:adaa5c99b7c23a00bac52d15a2469764e"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C callback function.  <a href="#adaa5c99b7c23a00bac52d15a2469764e">More...</a><br /></td></tr>
<tr class="separator:adaa5c99b7c23a00bac52d15a2469764e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b244d734eccc02dee744a50ac3aba1"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_i2_c_8h.html#adf9ba181c193aea867303fb6e6471db9">I2C_BitRate_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a47b244d734eccc02dee744a50ac3aba1">I2C_BitRate</a></td></tr>
<tr class="memdesc:a47b244d734eccc02dee744a50ac3aba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C bitRate.  <a href="#a47b244d734eccc02dee744a50ac3aba1">More...</a><br /></td></tr>
<tr class="separator:a47b244d734eccc02dee744a50ac3aba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d59fc71988958e7025a17307ada749"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___params__.html">I2C_Params_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749">I2C_Params</a></td></tr>
<tr class="memdesc:a98d59fc71988958e7025a17307ada749"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Parameters.  <a href="#a98d59fc71988958e7025a17307ada749">More...</a><br /></td></tr>
<tr class="separator:a98d59fc71988958e7025a17307ada749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a829a2a0fd594c50e93c3e55c7d04aa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a7a829a2a0fd594c50e93c3e55c7d04aa">I2C_CancelFxn</a>) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:a7a829a2a0fd594c50e93c3e55c7d04aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a8cad0c04a9eca0fffc0ffe5586a5179b" title="Cancel all I2C transfers. ">I2C_cancel()</a>.  <a href="#a7a829a2a0fd594c50e93c3e55c7d04aa">More...</a><br /></td></tr>
<tr class="separator:a7a829a2a0fd594c50e93c3e55c7d04aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083200108e980a0ef61e458f0b9fb9e7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a083200108e980a0ef61e458f0b9fb9e7">I2C_CloseFxn</a>) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:a083200108e980a0ef61e458f0b9fb9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d" title="Close an I2C peripheral specified by an I2C_Handle. ">I2C_close()</a>.  <a href="#a083200108e980a0ef61e458f0b9fb9e7">More...</a><br /></td></tr>
<tr class="separator:a083200108e980a0ef61e458f0b9fb9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3563e0ae9a6ce2be82bdc938ae5218"><td class="memItemLeft" align="right" valign="top">typedef int_fast16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a2b3563e0ae9a6ce2be82bdc938ae5218">I2C_ControlFxn</a>) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, uint_fast16_t cmd, void *controlArg)</td></tr>
<tr class="memdesc:a2b3563e0ae9a6ce2be82bdc938ae5218"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a4c74b1b9f8e76ac22bec7608491cb223" title="Perform implementation-specific features on a given I2C_Handle. ">I2C_control()</a>.  <a href="#a2b3563e0ae9a6ce2be82bdc938ae5218">More...</a><br /></td></tr>
<tr class="separator:a2b3563e0ae9a6ce2be82bdc938ae5218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb2451c8a1ce70402e43e4743c5fedf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#adfb2451c8a1ce70402e43e4743c5fedf">I2C_InitFxn</a>) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:adfb2451c8a1ce70402e43e4743c5fedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a>.  <a href="#adfb2451c8a1ce70402e43e4743c5fedf">More...</a><br /></td></tr>
<tr class="separator:adfb2451c8a1ce70402e43e4743c5fedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add24fcdaaf1bdef1521ce2489bf1d80e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#add24fcdaaf1bdef1521ce2489bf1d80e">I2C_OpenFxn</a>) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:add24fcdaaf1bdef1521ce2489bf1d80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>.  <a href="#add24fcdaaf1bdef1521ce2489bf1d80e">More...</a><br /></td></tr>
<tr class="separator:add24fcdaaf1bdef1521ce2489bf1d80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa785484e689c79262f98208689fecd38"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#aa785484e689c79262f98208689fecd38">I2C_TransferFxn</a>) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51">I2C_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:aa785484e689c79262f98208689fecd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a>.  <a href="#aa785484e689c79262f98208689fecd38">More...</a><br /></td></tr>
<tr class="separator:aa785484e689c79262f98208689fecd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fd875c3596b3856b6f1aebbceb3085"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___fxn_table__.html">I2C_FxnTable_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a58fd875c3596b3856b6f1aebbceb3085">I2C_FxnTable</a></td></tr>
<tr class="memdesc:a58fd875c3596b3856b6f1aebbceb3085"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of an I2C function table that contains the required set of functions to control a specific I2C driver implementation.  <a href="#a58fd875c3596b3856b6f1aebbceb3085">More...</a><br /></td></tr>
<tr class="separator:a58fd875c3596b3856b6f1aebbceb3085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43e4c7b224a8cc37764acb792182453"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___config__.html">I2C_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#ae43e4c7b224a8cc37764acb792182453">I2C_Config</a></td></tr>
<tr class="memdesc:ae43e4c7b224a8cc37764acb792182453"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C global configuration.  <a href="#ae43e4c7b224a8cc37764acb792182453">More...</a><br /></td></tr>
<tr class="separator:ae43e4c7b224a8cc37764acb792182453"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa47ee1c12e45d10f0beb6ed724704dfe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfe">I2C_TransferMode_</a> { <a class="el" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, 
<a class="el" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>
 }<tr class="memdesc:aa47ee1c12e45d10f0beb6ed724704dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer mode.  <a href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa47ee1c12e45d10f0beb6ed724704dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9ba181c193aea867303fb6e6471db9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#adf9ba181c193aea867303fb6e6471db9">I2C_BitRate_</a> { <a class="el" href="_i2_c_8h.html#adf9ba181c193aea867303fb6e6471db9a966fd2df13b3a9825615c50335cf1987">I2C_100kHz</a> = 0, 
<a class="el" href="_i2_c_8h.html#adf9ba181c193aea867303fb6e6471db9a83cc3750242e6ae9194cd7ed94f764d9">I2C_400kHz</a> = 1
 }<tr class="memdesc:adf9ba181c193aea867303fb6e6471db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C bitRate.  <a href="_i2_c_8h.html#adf9ba181c193aea867303fb6e6471db9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adf9ba181c193aea867303fb6e6471db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8cad0c04a9eca0fffc0ffe5586a5179b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a8cad0c04a9eca0fffc0ffe5586a5179b">I2C_cancel</a> (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:a8cad0c04a9eca0fffc0ffe5586a5179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all I2C transfers.  <a href="#a8cad0c04a9eca0fffc0ffe5586a5179b">More...</a><br /></td></tr>
<tr class="separator:a8cad0c04a9eca0fffc0ffe5586a5179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c86d89a687f2ee1eb980d99c32326d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d">I2C_close</a> (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:a12c86d89a687f2ee1eb980d99c32326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an I2C peripheral specified by an I2C_Handle.  <a href="#a12c86d89a687f2ee1eb980d99c32326d">More...</a><br /></td></tr>
<tr class="separator:a12c86d89a687f2ee1eb980d99c32326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c74b1b9f8e76ac22bec7608491cb223"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a4c74b1b9f8e76ac22bec7608491cb223">I2C_control</a> (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, uint_fast16_t cmd, void *controlArg)</td></tr>
<tr class="memdesc:a4c74b1b9f8e76ac22bec7608491cb223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform implementation-specific features on a given I2C_Handle.  <a href="#a4c74b1b9f8e76ac22bec7608491cb223">More...</a><br /></td></tr>
<tr class="separator:a4c74b1b9f8e76ac22bec7608491cb223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff51ddf1d325776fef90cce0223772b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b">I2C_init</a> (void)</td></tr>
<tr class="memdesc:a9ff51ddf1d325776fef90cce0223772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the I2C module.  <a href="#a9ff51ddf1d325776fef90cce0223772b">More...</a><br /></td></tr>
<tr class="separator:a9ff51ddf1d325776fef90cce0223772b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db3461e1e956d9b86af414da2fb05f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6">I2C_open</a> (uint_least8_t index, <a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:a2db3461e1e956d9b86af414da2fb05f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines the operating mode, and any related settings.  <a href="#a2db3461e1e956d9b86af414da2fb05f6">More...</a><br /></td></tr>
<tr class="separator:a2db3461e1e956d9b86af414da2fb05f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11636302074d67180207ab81ceb323c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c">I2C_Params_init</a> (<a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:ab11636302074d67180207ab81ceb323c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an I2C_Params struct to its defaults.  <a href="#ab11636302074d67180207ab81ceb323c">More...</a><br /></td></tr>
<tr class="separator:ab11636302074d67180207ab81ceb323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d827b67fe77d7d179026941cc069d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a> (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51">I2C_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:ac5d827b67fe77d7d179026941cc069d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an I2C transaction with an I2C slave peripheral.  <a href="#ac5d827b67fe77d7d179026941cc069d7">More...</a><br /></td></tr>
<tr class="separator:ac5d827b67fe77d7d179026941cc069d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1d8718f847129c7aa61dd1c264d8a13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8718f847129c7aa61dd1c264d8a13c">&sect;&nbsp;</a></span>I2C_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___config__.html">I2C_Config_</a>* <a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from an <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> call. </p>

</div>
</div>
<a id="adb9098b8bae10ab04381350227058a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9098b8bae10ab04381350227058a51">&sect;&nbsp;</a></span>I2C_Transaction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___transaction__.html">I2C_Transaction_</a>  <a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51">I2C_Transaction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transaction. </p>
<p>This structure defines an I2C transaction. It specifies the buffer(s) and buffer size(s) to be written to and/or read from an I2C slave peripheral. arg is an optional user-supplied argument that will be passed to the user-supplied callback function when the I2C driver is in I2C_MODE_CALLBACK. nextPtr is a pointer used internally by the driver for queuing of multiple transactions; this value must never be modified by the user application. </p>

</div>
</div>
<a id="aafde66e55b9cc9b1b0b7a2b924db4e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafde66e55b9cc9b1b0b7a2b924db4e83">&sect;&nbsp;</a></span>I2C_TransferMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfe">I2C_TransferMode_</a>  <a class="el" href="_i2_c_8h.html#aafde66e55b9cc9b1b0b7a2b924db4e83">I2C_TransferMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer mode. </p>
<p>I2C_MODE_BLOCKING blocks task execution while an I2C transfer is in progress. I2C_MODE_CALLBACK does not block task execution, but calls a callback function when the I2C transfer has completed. </p>

</div>
</div>
<a id="adaa5c99b7c23a00bac52d15a2469764e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa5c99b7c23a00bac52d15a2469764e">&sect;&nbsp;</a></span>I2C_CallbackFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_CallbackFxn) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51">I2C_Transaction</a> *transaction, bool transferStatus)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C callback function. </p>
<p>User-definable callback function prototype. The I2C driver will call this callback upon transfer completion, specifying the I2C handle for the transfer (as returned from <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>), the pointer to the I2C_Transaction that just completed, and the return value of <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a>. Note that this return value will be the same as if the transfer were performed in blocking mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I2C_Handle</td><td>I2C_Handle</td></tr>
    <tr><td class="paramname">I2C_Transaction*</td><td>Address of the I2C_Transaction</td></tr>
    <tr><td class="paramname">bool</td><td>Result of the I2C transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47b244d734eccc02dee744a50ac3aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b244d734eccc02dee744a50ac3aba1">&sect;&nbsp;</a></span>I2C_BitRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_i2_c_8h.html#adf9ba181c193aea867303fb6e6471db9">I2C_BitRate_</a>  <a class="el" href="_i2_c_8h.html#a47b244d734eccc02dee744a50ac3aba1">I2C_BitRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C bitRate. </p>
<p>Specifies one of the standard I2C bus bit rates for I2C communications. The default is I2C_100kHz. </p>

</div>
</div>
<a id="a98d59fc71988958e7025a17307ada749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d59fc71988958e7025a17307ada749">&sect;&nbsp;</a></span>I2C_Params</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___params__.html">I2C_Params_</a>  <a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749">I2C_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Parameters. </p>
<p>I2C parameters are used with the <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> call. Default values for these parameters are set using <a class="el" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c" title="Initialize an I2C_Params struct to its defaults. ">I2C_Params_init()</a>.</p>
<p>If I2C_TransferMode is set to I2C_MODE_BLOCKING, <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> function calls will block thread execution until the transaction has completed. In this case, the transferCallbackFxn parameter will be ignored.</p>
<p>If I2C_TransferMode is set to I2C_MODE_CALLBACK, <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> will not block thread execution, but it will call the function specified by transferCallbackFxn upon transfer completion. Sequential calls to <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> in I2C_MODE_CALLBACK will put the I2C_Transaction structures onto an internal queue that automatically starts queued transactions after the previous transaction has completed. This queuing occurs regardless of any error state from previous transactions.</p>
<p>I2C_BitRate specifies the I2C bus rate used for I2C communications.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c" title="Initialize an I2C_Params struct to its defaults. ">I2C_Params_init()</a> </dd></dl>

</div>
</div>
<a id="a7a829a2a0fd594c50e93c3e55c7d04aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a829a2a0fd594c50e93c3e55c7d04aa">&sect;&nbsp;</a></span>I2C_CancelFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_CancelFxn) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a8cad0c04a9eca0fffc0ffe5586a5179b" title="Cancel all I2C transfers. ">I2C_cancel()</a>. </p>

</div>
</div>
<a id="a083200108e980a0ef61e458f0b9fb9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083200108e980a0ef61e458f0b9fb9e7">&sect;&nbsp;</a></span>I2C_CloseFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_CloseFxn) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d" title="Close an I2C peripheral specified by an I2C_Handle. ">I2C_close()</a>. </p>

</div>
</div>
<a id="a2b3563e0ae9a6ce2be82bdc938ae5218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3563e0ae9a6ce2be82bdc938ae5218">&sect;&nbsp;</a></span>I2C_ControlFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast16_t(* I2C_ControlFxn) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, uint_fast16_t cmd, void *controlArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a4c74b1b9f8e76ac22bec7608491cb223" title="Perform implementation-specific features on a given I2C_Handle. ">I2C_control()</a>. </p>

</div>
</div>
<a id="adfb2451c8a1ce70402e43e4743c5fedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb2451c8a1ce70402e43e4743c5fedf">&sect;&nbsp;</a></span>I2C_InitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_InitFxn) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a>. </p>

</div>
</div>
<a id="add24fcdaaf1bdef1521ce2489bf1d80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add24fcdaaf1bdef1521ce2489bf1d80e">&sect;&nbsp;</a></span>I2C_OpenFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>(* I2C_OpenFxn) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749">I2C_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>. </p>

</div>
</div>
<a id="aa785484e689c79262f98208689fecd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa785484e689c79262f98208689fecd38">&sect;&nbsp;</a></span>I2C_TransferFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* I2C_TransferFxn) (<a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> handle, <a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51">I2C_Transaction</a> *transaction)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a>. </p>

</div>
</div>
<a id="a58fd875c3596b3856b6f1aebbceb3085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fd875c3596b3856b6f1aebbceb3085">&sect;&nbsp;</a></span>I2C_FxnTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___fxn_table__.html">I2C_FxnTable_</a>  <a class="el" href="_i2_c_8h.html#a58fd875c3596b3856b6f1aebbceb3085">I2C_FxnTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of an I2C function table that contains the required set of functions to control a specific I2C driver implementation. </p>

</div>
</div>
<a id="ae43e4c7b224a8cc37764acb792182453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43e4c7b224a8cc37764acb792182453">&sect;&nbsp;</a></span>I2C_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___config__.html">I2C_Config_</a>  <a class="el" href="_i2_c_8h.html#ae43e4c7b224a8cc37764acb792182453">I2C_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C global configuration. </p>
<p>The I2C_Config structure contains a set of pointers used to characterize the I2C driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa47ee1c12e45d10f0beb6ed724704dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47ee1c12e45d10f0beb6ed724704dfe">&sect;&nbsp;</a></span>I2C_TransferMode_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i2_c_8h.html#aa47ee1c12e45d10f0beb6ed724704dfe">I2C_TransferMode_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer mode. </p>
<p>I2C_MODE_BLOCKING blocks task execution while an I2C transfer is in progress. I2C_MODE_CALLBACK does not block task execution, but calls a callback function when the I2C transfer has completed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa47ee1c12e45d10f0beb6ed724704dfeabe065350be2a0ae5c9beb24624626c75"></a>I2C_MODE_BLOCKING&#160;</td><td class="fielddoc"><p><a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> blocks execution </p>
</td></tr>
<tr><td class="fieldname"><a id="aa47ee1c12e45d10f0beb6ed724704dfea129731a7edeb285f43a54b2cf9f5ac72"></a>I2C_MODE_CALLBACK&#160;</td><td class="fielddoc"><p><a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> does not block </p>
</td></tr>
</table>

</div>
</div>
<a id="adf9ba181c193aea867303fb6e6471db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9ba181c193aea867303fb6e6471db9">&sect;&nbsp;</a></span>I2C_BitRate_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i2_c_8h.html#adf9ba181c193aea867303fb6e6471db9">I2C_BitRate_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C bitRate. </p>
<p>Specifies one of the standard I2C bus bit rates for I2C communications. The default is I2C_100kHz. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adf9ba181c193aea867303fb6e6471db9a966fd2df13b3a9825615c50335cf1987"></a>I2C_100kHz&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adf9ba181c193aea867303fb6e6471db9a83cc3750242e6ae9194cd7ed94f764d9"></a>I2C_400kHz&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8cad0c04a9eca0fffc0ffe5586a5179b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cad0c04a9eca0fffc0ffe5586a5179b">&sect;&nbsp;</a></span>I2C_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel all I2C transfers. </p>
<p>This function will cancel asynchronous <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> operations, and is applicable only for I2C_MODE_CALLBACK. An in progress transfer, as well as any queued transfers will be canceled. The individual callback functions for each transfer will be called from the context that <a class="el" href="_i2_c_8h.html#a8cad0c04a9eca0fffc0ffe5586a5179b" title="Cancel all I2C transfers. ">I2C_cancel()</a> is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>I2C_Transfer() has been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>An I2C_Handle returned from <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Different I2C slave devices will behave differently when an in-progress transfer fails and needs to be canceled. The slave may need to be reset, or there may be other slave-specific steps that can be used to successfully resume communication.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> </dd></dl>

</div>
</div>
<a id="a12c86d89a687f2ee1eb980d99c32326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c86d89a687f2ee1eb980d99c32326d">&sect;&nbsp;</a></span>I2C_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an I2C peripheral specified by an I2C_Handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> has been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>An I2C_Handle returned from <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> </dd></dl>

</div>
</div>
<a id="a4c74b1b9f8e76ac22bec7608491cb223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c74b1b9f8e76ac22bec7608491cb223">&sect;&nbsp;</a></span>I2C_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t I2C_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>controlArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform implementation-specific features on a given I2C_Handle. </p>
<p>Commands for <a class="el" href="_i2_c_8h.html#a4c74b1b9f8e76ac22bec7608491cb223" title="Perform implementation-specific features on a given I2C_Handle. ">I2C_control()</a> can originate from <a class="el" href="_i2_c_8h.html" title="I2C driver interface. ">I2C.h</a> or from implementation specific I2C*.h (I2CCC26XX.h_, I2CMSP432.h_, etc.) files. While commands from <a class="el" href="_i2_c_8h.html" title="I2C driver interface. ">I2C.h</a> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific I2C*.h files add unique driver capabilities but are not API portable across all I2C driver implementations.</p>
<p>Commands supported by <a class="el" href="_i2_c_8h.html" title="I2C driver interface. ">I2C.h</a> follow a I2C_CMD_&lt;cmd&gt; naming convention.<br />
 Commands supported by I2C*.h follow a I2C*_CMD_&lt;cmd&gt; naming convention.<br />
 Each control command defines <b>arg</b> differently. The types of <b>arg</b> are documented with each command.</p>
<p>See <a class="el" href="group___i2_c___c_m_d.html">I2C_control command codes</a> for command codes.</p>
<p>See <a class="el" href="group___i2_c___s_t_a_t_u_s.html">I2C_control return status codes</a> for status codes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>An I2C_Handle returned from <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td><a class="el" href="_i2_c_8h.html" title="I2C driver interface. ">I2C.h</a> or I2C*.h command.</td></tr>
    <tr><td class="paramname">controlArg</td><td>An optional R/W (read/write) command argument accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation-specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a> </dd></dl>

</div>
</div>
<a id="a9ff51ddf1d325776fef90cce0223772b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff51ddf1d325776fef90cce0223772b">&sect;&nbsp;</a></span>I2C_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the I2C module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The I2C_config structure must exist and be persistent before this function can be called. This function must also be called before any other I2C driver APIs. This function call does not modify any peripheral registers. </dd></dl>

</div>
</div>
<a id="a2db3461e1e956d9b86af414da2fb05f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db3461e1e956d9b86af414da2fb05f6">&sect;&nbsp;</a></span>I2C_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a> I2C_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749">I2C_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines the operating mode, and any related settings. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The I2C controller has been initialized, via a previous call to <a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Logical peripheral number for the I2C indexed into the I2C_config table</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to a parameter block. Default values will be used if NULL is specified for params. All the fields in this structure are are considered RO (read-only).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An I2C_Handle on success, or NULL on an error, or if the peripheral is already opened.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a> </dd>
<dd>
<a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d" title="Close an I2C peripheral specified by an I2C_Handle. ">I2C_close()</a> </dd></dl>

</div>
</div>
<a id="ab11636302074d67180207ab81ceb323c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11636302074d67180207ab81ceb323c">&sect;&nbsp;</a></span>I2C_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a98d59fc71988958e7025a17307ada749">I2C_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an I2C_Params struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A pointer to I2C_Params structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: transferMode = I2C_MODE_BLOCKING transferCallbackFxn = NULL bitRate = I2C_100kHz </p>

</div>
</div>
<a id="ac5d827b67fe77d7d179026941cc069d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d827b67fe77d7d179026941cc069d7">&sect;&nbsp;</a></span>I2C_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a1d8718f847129c7aa61dd1c264d8a13c">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#adb9098b8bae10ab04381350227058a51">I2C_Transaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an I2C transaction with an I2C slave peripheral. </p>
<p>This function will perform an I2C transfer, as specified by an I2C_Transaction structure.</p>
<p>An I2C transaction may write data to a peripheral, or read data from a peripheral, or both write and read data, in a single transaction. If there is any data to be written, it will always be sent before any data is read from the peripheral.</p>
<p>The data written to the peripheral is preceded with the peripheral's 7-bit I2C slave address (with the Write bit set). After all the data has been transmitted, the driver will evaluate if any data needs to be read from the device. If yes, another START bit is sent, along with the same 7-bit I2C slave address (with the Read bit). After the specified number of bytes have been read, the transfer is ended with a NACK and a STOP bit. Otherwise, if no data is to be read, the transfer is concluded with a STOP bit.</p>
<p>In I2C_MODE_BLOCKING, <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> will block thread execution until the transaction completes. Therefore, this function must only be called from an appropriate thread context (e.g., Task context for the TI-RTOS kernel).</p>
<p>In I2C_MODE_CALLBACK, the <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> call does not block thread execution. Instead, a callback function (specified during <a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open()</a>, via the transferCallbackFxn field in the I2C_Params structure) is called when the transfer completes. Success or failure of the transaction is reported via the callback function's bool argument. If a transfer is already in progress, the new transaction is put on an internal queue. The driver services the queue in a first come first served basis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>An I2C_Handle</td></tr>
    <tr><td class="paramname">transaction</td><td>A pointer to an I2C_Transaction. All of the fields within the transaction structure should be considered write only, unless otherwise noted in the driver implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The I2C_Transaction structure must persist unmodified until the corresponding call to <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> has completed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>In I2C_MODE_BLOCKING: true for a successful transfer; false for an error (for example, an I2C bus fault (NACK)).</dd></dl>
<p>In I2C_MODE_CALLBACK: always true. The transferCallbackFxn's bool argument will be true to indicate success, and false to indicate an error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#a2db3461e1e956d9b86af414da2fb05f6" title="Initialize a given I2C peripheral as identified by an index value. The I2C_Params structure defines t...">I2C_open</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2017, Texas Instruments Incorporated
</small>
</body>
</html>
